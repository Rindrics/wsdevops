---
title: "my noble research"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{paper}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
library(ggplot2)
library(dplyr)
devtools::load_all(".")
data(my_iris)
table_nums <- captioner::captioner(prefix = "Table")
table_cap  <- table_nums(name = "iristable", 
                         caption = "Summary of iris data")
fig_nums <- captioner::captioner(prefix = "Fig.")
sepal    <- fig_nums(name = "sepal",
                     caption = "Length--width relationship of iris sepals by species")
petal    <- fig_nums(name = "petal",
                     caption = "Length--width relationship of iris petals by species")

```
# Introduction
簡単な論文をRパッケージのドキュメントとして書いてみましょう。
この論文自体に学術的価値は全くありませんが、
論文執筆を含む全ての知的労働がソフトウェア開発そのものであることを実感できるでしょう。

## 特に重要な概念
我々研究者が特に意識して学ぶべき概念は以下の3つです。

- テスト
- ドキュメント生成
- ビルド

テストは、開発者（ここでは著者）がソフトウェア（ここではデータ、関数、そして論文そのもの）に対して期待している事項をコードの形で書き表したものです。
違う切り口で解釈すれば、テストはあなたの心強い味方です。
あなたが、研究の大目的を達成するうえで必要な個々の小問題を、確かに解決したことを客観的に保証してくれるのです。
テストコードは独自に書くこともできますが、既存のテストフレームワークを用いるのが賢明です。
R言語では、プログラムをスクリプトではなくパッケージとして開発することによって、
`testthat`パッケージを利用できます。

ドキュメント生成の必要性を低レベルな観点から説明すれば、「人的ミス混入の余地をなくす上で不可欠」といったところでしょうか。
この概念がないプロジェクトに巻き込まれた不幸な作業者は、計算結果をドキュメントに手作業で貼り付けなければなりません[^1]。
執筆コストはドキュメントの規模とともに指数関数的に増加しますし[^2]、何より、肝心のドキュメントは常にデグレードの危険にさらされています。
一方、ドキュメントをコードから生成しているプロジェクトでは、ドキュメントの規模が大きくなっても執筆コストの増加は緩やかです[^3]。
より高次の観点に立つと、ドキュメント生成の必要性についての説明はもっと率直になります。


ドキュメントを変更していないなら、コミットは生じるはずがないからです。

[^1]: どうして既にマシンのメモリ上にある計算結果を、わざわざ文字の形に変換してディスプレイに表示し、空気を介して作業者の網膜に投影し、視神経を興奮させる必要があるのでしょうか？私にはわかりません

[^2]: 作業コストは$O(n^2$)でしょうか、$O(n^3$)でしょうか

[^3]: 概ね$O(\log n)$と$O(n)$の間に収まるでしょう

ビルドは、簡単にいえばソフトウェア（ここでは論文）を組み立てることです。
より重要な解釈としては、ビルドが成功したということは、
提供しようとしている価値を実際に生み出すことができたことを意味します[^4]。
また、ビルド成功が意味するもう一つの重要な事柄は、全ての計算が完了し、ソフトウェアが全てのテストに合格したこということです。
論文をソフトウェアとして開発することで、あなたは論理の組み立てやモデルの修正でどんなに疲弊していようと、
論文をデグレードさせることなく執筆を進めることができます。

[^4]: ユーザーがそれを気に入ってくれるかどうかはまた別問題です

## DevOpsへの入り口
「ビルドボタン」は指先一つで価値の創造を可能にする強力なツールです。
しかし人間は忘れる生き物です。
我々がビルドボタンを押し忘れないためには、どうしたらよいでしょうか。
ビルドしたかどうかを「ダブルチェックせよ[^5]」というのは某組織が大好きな精神論ですが、
こういったこまごました雑用は全て自動化しておく必要があります。

[^5]: 「トリプル」も実際に聞いたことがあります

継続的インテグレーション（CI: Continuous Integration）は、
いわば、コンピュータが自動的にビルドボタンを押してくれる仕組みです。
リポジトリへに変更がコミットされるたびに、ソフトウェアが自動的にビルドされます。
それぞれのビルドはリポジトリへのそれぞれのコミットに対応した個別のIDで管理されているため、
もしビルドが壊れた場合、どのコミットが犯人かを特定することができます。
ビルドに成功したソフトウェアをユーザーが利用可能な場所にアップロードするところまでを自動化すれば、
継続的デプロイ（CDep: Continuous Deploy）が完成します。

この勉強会では、本パッケージのリポジトリをチャットツールと連携することで、
GitHubワークフローを見える化します。
DevOpsへの入り口を体験することで、研究活動をソフトウェア開発の視点から解釈してみましょう。




# Materials & methods
本研究にはirisデータを使いました。
irisデータは`r length(unique(my_iris$Species))`種（`r unique(my_iris$Species)`）のアヤメについて、花弁と萼片の長さと幅を記録したサンプルデータです。


ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。

# Reults

アヤメの花弁と萼片の長さと幅について、種別にまとめました（`r table_nums("iristable", display = "cite")`）。

ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。

`r table_nums("iristable")`
```{r fig.cap = table_cap, echo = FALSE}
my_iris %>%
  group_by(Species) %>%
  summarize("Sepal Lqength (mm)" = my_range(Sepal.Length),
            "Sepal Width (mm)" = my_range(Sepal.Width),
            "Petal Length (mm)" = my_range(Petal.Length),
            "Petal Width (mm)" = my_range(Petal.Width)) %>%
  knitr::kable()
  
```


ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。

## 花弁
花弁の長さと幅の関係を調べました（`r fig_nums("sepal", display = "cite")`）

ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。

ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。

```{r, fig.cap = sepal, echo = FALSE}
my_iris %>%
  ggplot(aes(Sepal.Length, Sepal.Width, color = Species)) +
  geom_point()
```

## 萼片
萼片の長さと幅の関係についても調べました（`r fig_nums("petal", display = "cite")`）

ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。

ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。

```{r, fig.cap = petal, echo = FALSE}
my_iris %>%
  ggplot(aes(Petal.Length, Petal.Width, color = Species)) +
  geom_point()
```

# Discussion
花弁（`r fig_nums("sepal", display = "cite")`）および
萼片（`r fig_nums("petal", display = "cite")`）の
長さと幅の関係を利用して、種判別ができるかもと思いました。

ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。ぞうの卵は大きいぞう。
